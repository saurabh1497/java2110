
Envionment Setup 
-----------------------
    1. jdk or openjdk 8
    2. IDE / Editor 
            - Eclipse for JEE
            - IntellIj
            - STS - Spring tool suite 
    3. NodeJS 12.x 
    4. Database 
            - MySQL community 
            - Oracle 
            - H2 

    Java 
    -----------
    Programming language        : programming capabilities 

    Runtime Environment         : 

    Standard Library            : 



    JVM - java virtual machine 
        - responsible to execute program on the given platform 

    JRE - java runtime environment 
            - JVM + standard libraries 

    JDK - Java Development kit 
            - JRE + development tools i.e. javac, jar, debug, etc.


    Java SE 
        - standard libraries i.e. collection, util, io, etc. 
        - core java

    Java EE 
        - enterprise applications 
        - component based 
                - web components 
                        servlet, JSP, JSTL, EL 
                - distributed tech  
                        CORBA, EJB, web services 
        - Service oriented 
                - JTA, JMS, JAVA MAIL, JCA 

        - protocol based 
                - HTTPServlet 

    Java ME 
        - small devices 


   1 hr 
    ------------
        - java basics 
            - variable in java 
                    - local variables 

                        public class X {

                            void methodA(){
                                 int i;

                                //
                                //

                            }
                        }

                    - instance variables 

                    - static variables 

            - data types

                1. primitive types 

                    byte        -128 to 127     1 byte
                    short       
                    int 
                    long 
                    float
                    double 
                    boolean 
                    char 

                2. Reference types 
                        - variable of type arrays, strings, class, interfaces are ref types 
                        - they store reference to the objects in memory 

            - decision making 
                    if statement 
                    if-else statement 
                    if-else if - if statement 
                    switch statement 

            - looping statement 
                    - while loop 
                    - for loop 
                    - do while 



            int a = 10;
            int b = 20;

            - Arrays 
            ---------------
                    - store multiple values/elements of same type 
                    - arrays are objects in java 
                    - array size is fixed 
                    - you can have array of primitives as well as objects 

            - declare array variable 

                    <datatype>[] array-var-name;

                    int[] nums;    

            - create an array 
                    array-var-name = new <datatype>[size];
                    nums = new int[5];


















    class Product {

        static String category;

       
        
        int pid;
        String pname;
        float price;
    }


    Product p1 = new Product();         pid   pname   price 


Array Manipulation
----------------------

        int[] arr = {10,40,503,20,40,20,30,40};

        for(int i=0; i<arr.length; i++){
            ....
            ...
        }

        Enahanced for loop 
        -------------------------
        for(int loopVar : arr){

        }

        java.util package provides "Arrays" class, which provides methods to manipulate arrays 

        - int binarySearch(int[] arr, int searchValue)
        - boolean equals(int[] arr)
        - copyOf()
        - sort()

                int[] arr1 = {10,20,30};

                int[] arr2 = Arrays.copyOf(arr1, 2)


    int[] arr1 = {1,2,3,3,4,4,43,43, .......................};

	binarySearch(arr1, 0, 100, 77)


    Employee[] empArr = ..............................................


    Operators 
    ---------------
        - increment & decrement operator 
                pre-increment                post-increment 
                    ++x                         x++


                pre-decrement                   post-decrement 
                    --X                         x-- 



            int a  = 10;
            int b = ++a;
            system.out.println(b)       //11
            sysout.out.println(a)       //11


       - Arithmetic operators 
            + 
            -
            *
            /
            %

                byte + byte         = int 
                byte + short        = int 
                byte + int          = int 
                char + char         = int 
                char + int          = int 
                byte + char         = int 

                int + long          = long 
                float + double      = double 
                long + long         = long 
                long + float        = float 



            - String Concatenation 
            ----------------------
                

            - Relational operators 
            --------------------------
                    > 
                    < 
                    >=
                    <=
                    ==
                    !=

            - Assignment operators 
                a = a + 1       a+=1 

            - logical operators 



        POJO - plain old java objects 

                        class Employee {
                             //data/logic    
                        }


        Java Beans 
        ---------------

                - java beans are used to represent a data or certain business operations 

                - a class is called java bean, if it 
                        - implements Serializable interface 
                        - has a no-arg constructor 
                        - has all the members declared as private 
                        - has public getter/setter methods 


        OOPS Concepts 
        ---------------

        object
        -----------
                - object oriented programming languages 
                - object is an entity which has some state and behavior 

                        i.e. a pen ---- state = name, type, color, size, etc.
                                        behavior = write 
                             a person 

                             a bank account  --- state --- type, accountnumber, ......
                                                behavior - open, close, ...

        Class 
        --------
                - blueprint or template for objects 
                - we use classes to describe a type / entity 

        Object 
        -------
                - object is a living entity 
                - once a class is created, you can create any number of objects of that type 


        class <className> {

                //instance members
                //instance methods 
                //static members 
                //static methods 
                //constructors 
                //inner class
                //abstract methods 
        }

        class Car {

                //state/fields/datamembers/instance members
                String type;
                String model;
                String color;
                int speed;

                //constructor / special method / doesn't have return type / called automatically while create object
                //constructor is used to initalize values to the fields/datamembers
                Car(){

                }
        }


        class BankAccount {
              
                private long accountNumber;
                private double balance;

                public double getBalance(){
                        return this.balance;
                }

                public void setBalance(double amount){
                        //logic 
                        this.balance = amount;
                }

                public long getAccountNumber(){
                        return this.accountNumber;
                }

                //..
                //...
        }

        BankAccount b1 = new BankAccount();
         

        Encapsulation
        -------------
                - hiding the state or internal representation of an object from outsite the class 
                - allows controlling internal implementation
                - declare all the fields/datamembers as private 
                - provide  public getter/setter methods to access the data members 


        Method overloading  / Static binding / compile time polymorphism / Early binding 
        -------------------------------------------------------------------
                - writing multiple methods with same name but diff parameters is called overloading 
                - 2 methods are said to be overloaded when both method methods have same name but diff parameters 
                                - parameters should be diff in either type or numbers 

                - the right method is determined based on arguments passed while calling the method 
                - this decision is taken at compile 
                - in overloading exact match gets the highest priority
                - child class arugment gets priority than parent argument 
                - access modifier/ return type of the method is not considered in method overloading
                - automatic promotion
                        byte ---> short  |---- int -- long --- float --- double  
                                  char   |
                - in overloading, method with varargs has least priority                
                - overloading resolution always take place at compile time 
                        - the right method call is determined based on ref type (and not based on object type)

        
        this keyword
                - refer to the current instance 
        
        this() constructor 

        super keyword 
                - refers to the parent class 

        super() constructor 


        Inheritance
        ----------------
                - Reusability 
                - Maintainability 
                - Extendibility 

                - use 'extends' keyword to inherit from a super class 
                - a class can extend to only one class 
                - inheritance create IS-A relationship 
                - **in java, Oject class is the supermost class for all the classes implicitely 

                                Object 
                                  |
                                  |--> boolean equals(Object o)
                                  |-> int hashCode()
                                  |-> void wait(), void notify(), void notifyAll()
                                  |
                                Person 
                                   |
                                Employee 

        Association / Aggregation / Composition 
        -------------------------------------------
                - Association creates HAS-A relationship 
                - when a class has ref to another class 



                Aggregation:
                        - the objects do not own each other 
                        - the object can exist without another object 

                        - School  --- Student 

                Composition
                        - strong association 
                        - one object owns another object 
          
                        House   ----> Rooms 

                        Car ----> Engine 


        class Address {
                ..street, city, pin, state, ....
        }


        class Supplier {

                Address address;
        }


        class Customer {

                Address[] address;


        }


        final variable - cannot change value of variable once assigned 

        final method    - cannot be overridden in subclass 

        final class - cannot be sub-classed 

        class X{

                X(){
                        //initialize default values to the members 
                }

                 X(int a){

                }
        }

        X x = new X(3);

        abstract classes
        -------------------
                - we cannot instantiate an abstract class 
                - abstract classes can have public/private/protected members 
                - can have constructors, instance methods 
                - can have abstract methods 

                abstract class Car {

                        //data members/fields/instance members
                        
                        //instance methods

                        //constructors

                        //abstract methods 
                }

                class TataCar extends Car {

                }

                class BMWCar extends Car {

                }



        Abstract method
        -------------------
                - a method declared with 'abstract' keyword and without body
                - an abstract method must be implemented by its immediate subclass

                abstract class Car {

                        public abstract void move();
                       
                }

                class TataCar extends Car {

                        public void move(){
                                sout("this car moves smooth")
                        }
                }

                class BMWCar extends Car {

                        //override the method of super class
                        //re-define a super class method in subclass 
                        public void move(){
                                sout("this car moves fast");
                        }
                }

                class XyzCar extends Car {
                        //must override abstract method move();

                }

                Car car = new TataCar();
                car.move();                     //TataCar's  move();

                Car car = new BMWCar();
                car.move();                     //BMWCar's move() method



        Interface
        -------------------
                - set of requirements that a class has to implement 
                - interface has only public abstract methods (JAVA 7) and public static final data members  
                - a class  has to implement the interface and override the abstract methods 
                - a class can implement several interfaces 
                - an interface can extend another interface 
                - an interface can extends several interfaces 


                        interface A {
                                //methodA();
                        }

                        interface B {
                                //methodB();
                        }

                        interface C extends A, B {
                                //..
                        }

                        class X implements C{
                                methodA(){}
                                methodB(){}
                                //...
                        }

                interface Taxable {

                        public abstract double calcTax(double taxRate);
                }

                interface Deliverable {
                        public abstract void deliver();
                }

                class Toys implements Taxable {

                        public double calcTax(double taxRate){
                                // some code to calc tax value 
                                //return tax value
                        }
                }

                class Cloths implements Taxable, Deliverable {

                        public double calcTax(double taxRate){
                                // some code to calc tax value 
                                // return tax value
                        }

                        public void deliver(){
                                //...
                        }
                }


        **a variable of type superclass can reference to child object 

        Polymorphism / 
        ---------------------
                - a type can reference to diff objects at diff time, and based on the type of object 
                        it is pointing to, we want to invoke appropriate method 
                - this can be achieved through overriding 

                - Method Overriding / run time polymorphism / dynamic binding 
                - redefine a super class method in child class using the same method 
                        signature as super class


                1. only inherited methods are overridden 
                        class A {
                                public void methodA(){}
                        } 
                        class B extends A {
                                public void methodA(){}
                        }
                2. private, static, final methods of superclass cannot be overridden 

                3. overridden method must have same signature i.e. same name, same parameters

                4. overriding method must have same return type or subtype 

                         class A {
                                public Object methodA(){}
                        } 
                        class B extends A {
                                public <anyClass> methodA(){}
                        }
                5. overriding method must not have more restrictive access 
                        class A {
                                protected void methodA(){}
                        } 
                        class B extends A {
                                public void methodA(){}
                        }


        Encapsulation 
        Inheritance 
        Abstraction 
        Polymorphism

        String, StringBuilder, StringBuffer, StringTokenizer 
        -------------------------------------------------------

        String class 
        ----------------
                - create string object 
                - String objects immutable / not modifiable 

                1. String str = "Welcome";

                2. String str = new String("welcome");

                3. char[] charArr = {'h','e','l','l','o'}
                        String str = new String(charArr);


        String interning
        ----------------
                - jvm optimizes the amount of memory for string objects, by allocating only 
                \       one single copy of each literal string in the pool 


        String class methods 
        ----------------------
                int length()

                String concat(String s);

                boolean equals(String s)

                boolean equalsIgnoreCase(String s)

                char charAt(int index)

                int compareTo(String s)

                boolean startsWith(String s)

                boolean endsWith(String s)
                
                int indexOf(String s)           int indexOf(char ch)

                int lastIndexOf(String s)           int lastIndexOf(char ch)

                String toUpperCase()

                String toLowerCase() 

                String[] split();

        StringBuilder, StringBuffer
        ------------------------------



        StringTokenizer
        ----------------
                - allows to break a string into tokens 
                - StringTokenizer(String str)
                - StringTokenizer(String str, String delimiter)
                -...

        Wrapper classes 
        -----------------
                - for each primitive there is a corresponding referece type availalble at java.lang package 
                                i.e. for primitive int there is class called as Integer 
                - whever you want to treat primitives as ref types i
                        i.e. working with Collections 
                        i.e. working with Generics 
                - wrapper classes provides conversion methods 

                      int i =  Interger.parseInt("132");

                byte                    Byte 
                short                   Short 
                int                     Integer 
                long                    Long 
                char                    Character
                boolean                 Boolean 
                float                   Float 
                double                  Double  


        - Boxing 
                - conversion a primitve type into ref type 


                public void methodA(Object obj){

                }


                methodA(20);            //Integer object



        - Unboxing 
                - conversion of ref type to primitive type 


Java Essentials 
-------------------
        - Java Basics 
        - J2EE, J2SE, J2ME
        - JVM, JRE, JDK 
        - Decision making 
        - looping statements 
        - operators / expressions 
        - arrays 
        - String 
        - OOPS 
        - Object class i.e. toString()


Standard Library 
------------------

        Collection Framework 
        --------------------
                - provides dynamically allocated data structures 
                - java.util package provides set of interfaces, classes  


                        Iterable<E> interface 
                                |
                        Collection<E>  Interface 
                                |
                                |
                                |
                                |
        -------------------------------------------------------------------------------------------
        List<E> interface                 Set<E> interface                     Queue<E> interface 
                |                               |                                       |
                |                               |                                       |
                |                               |                                       |
        ArrayList<E>                        HashSet<E>                                  |
        LinkedList<E>                       LinkedHashSet<E>                    ---------------------------------------------------------------------------------
        Vector<E>                           TreeSet<E>                         Deque<E> interface              BlockingQueue<E> interface               PriorityQueue<E>
        Stack<E>                                                                        |                               |
                                                                ---------------------------------------           ArrayBlockingQueue<E>
                                                                BlockingDeque<E> Interface      ArrayDeque<E>
                                                                        |
                                                                ArrayBlockingDeque<E>



                                        Map<K,V> interface 
                                                |
                                        HashMAp<K,V>
                                        LinkedHashMap<K,V>
                                        TreeMap<K,V>








Collection<E>  Interface 
--------------------------
        - it is the supermost interface in collection hierarchy 
        - Collection interface methods ....
                boolean add(Object obj)
                boolean addAll(Collection c)
                boolean remove(Object obj)
                int size() 
                boolean contains(Object obj)
                .....

List<E> interface 
---------------------
        - subinterface of Collection interface
        - it models an index based collection of items
        - inserts the elements based on insertion order 
        - allows duplicates
        - list interface methods 
                - boolean add(int index, Object obj)
                - boolean remove(int index)
                - .....


        - implementation classes of List<E> interface 

                1. ArrayList<E>
                        - uses 'resizable array' as data structure 
                        - initial size = 10 
                        - performance is slower compared to LinkedList i.e. lot of shifting is required while inserting/removing elements 

                2. LinkedList<E>
                        - uses 'double linked list' as data structure 

                3. Vector<E>
                        - similar to arraylist class 
                        - uses 'resizable array' as data structure 
                        - it is synchronized 

                4. Stack<E> 
                        - similar to arraylist class 
                        - uses 'resizable array' as data structure 
                        - it is synchronized 
                        - uses LIFO approach 


        - Creating a list 

                non-generic lists
                --------------------
                        ArrayList list = new ArrayList();
                        ArrayList list = new ArrayList(int capacity);

                        LinkedList list = new LinkedList();
                Generic lists
                --------------
                        ArrayList<Integer> numsList = new ArrayList();
                        LinkedList<String> namesList = new LinkedList();

                        List<Integer> numslist = new ArrayList();



        - Operations on list 
        -------------------------
                -- add, remove, retrieve elements from the list 
                -- 


Set<E> interface 
-------------------
        - subinterface of Collection interface
        - it models a collection of unique elements, doesn't allow duplicates 
         
                                        Collection<E> interface
                                                |
                                                |
                                           Set<E> interface 
                                                |
                                                |
                                                |
                        -------------------------------------------------------
                        HashSet<E>                                      TreeSet<E>
                            |
                            |
                        LinkedHashSet<E>


        - implementation classes of Set<E> interface 

                1. Hashset<E>
                        - uses 'hashtable' datastructure 
                        - not synchronized
                        - doesn't not guarantee the order or insersion 

                2. LinkedHashSet<E>
                        - uses 'hashtable + double linked list' datastructure 
                        - not synchronized
                        - maintains insertion order

                3. TreeSet<E>
                        - uses 'balanced tree' datastructure 
                        - not synchronized
                        - maintains sorted order of elements 


        - Operations on set
        -------------------------
                - creating a set 
                - basic operations i.e. adding, removing, if set is empty, size of set etc. 
                - searching
                - iterating

        - ** hashCode() and equals() 
        --------------------------------
                - whevener we work with any hashtable based collection, we have to override both equals() and hascode() correctly 
                - hashCode()
                        - returns an integer value representing the current instance of the class 
                        - we have calculate this vlaue consistent with definition of equality of the calss 
                        - if we override the equals() method, we have have to override hashCode()

                - if two objects are equal, their hashcode is also equal 
                - if two objects are not equal, they may or may not have identical hashcode


        Natural ordering of elements 
        -------------------------------
                numbers         = alphanumeric 
                string          = alphabetic 
                date            = choronological 


        Comparable<E> interface 
        -------------------------
                interface Comparable<E>{
                        public int compareTo(E e);
                }

                the compareTo() method returns compare value 

                        0       = both objects are same 
                        >= 1     = the current object is greater than other object 
                        <= 1     = the current object is less than other object 


        Comparator<E> interface
        ------------------------- 
                - you can create external comparators 

                        interface Comparator<E>{
                                int compare(E objec1, E object2);
                        }


Queue<E> interface 
------------------
        - subinterface of Collection interface
        - it models a collection of items with FIFO approach, elements are stored in queue 


 Map<K,V> interface
 ---------------------
        -** not part of collection interface 
        - it models a collection of elements based on key-value pairs 
        - Keys cannot be duplicated 

        - map<K,V> interface methods 
        ---------------------------------

                        V put(K key, V value)

                        V get(K key)

                        boolean containsKey(Object key)

                        boolean containsValue(Object value)

                        Set<K> keySet()

                        Collection<V> values();

                        entrySet();


        - Map<E> implementation classes
        ------------------------------------

                1. HashTable<K,V>
                        - uses 'hashtable' as datastructure
                        - synchronized
                        - hashtable doesnt allow null key 

                2. HashMap<K,V>
                        - uses 'hashtable' as datastructure
                        - not synchronized / not threadsafe 
                        - hashmap allows one null key 

                3. LinkedHashMap<K,V>
                        - uses 'hashtable+double linked list' 
                        - ensures insertion order 

                4. TreeMap<K,V> 
                        - maintains sorted order of keys 


                class Manager{          //implement Comparable 
                        
                        //hashcode() and equals()


                }

                class Employee{

                }


                Map<Manager, List<Employee>> map = new TreeMap();               //or provide comparator 

                map.put(m1, list1);
                map.put(m1, list2);















        boolean equals(Object obj) method
        ----------------------------
                - this method belongs to object class 
                - we can override the equals() method in any class, and use it to compare objects 






        =======================
                **default implementatio of equals() method in object class 
                **Preserving equality contract ---- equals() and hashCode()
                **ListIterator, Iterator and Enumerator 
        ========================






        IO 


        Exception Handling 


        Threading / Concurrency API 


        JDBC 










        com.demo.model 
        class User {

                userid 
                email 
                password 
                fullname        
        }

        com.demo.client 

        UserMainTest{
                psvm(){
                        //CRUD operation on the User
                }
        }

        com.demo.dao
        class UserDAO{

                //collection object

                User create(User u){
                        //insert the given user into a collection 
                }

                User update(User u){
                        //update an existing user based on given details 

                }

                User get(int userid){

                }

                User delete(int userid){

                }

                List<User> getAll(){

                }

                int count(){

                }

        }